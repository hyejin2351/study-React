1.1 왜 리액트인가?

<다양한 프레임워크의 구조의 공통점>
-모델(model)과 뷰(view)가 있다. 
모델>
-애플리케이션에서 사용하는 데이터를 관리하는 영역
뷰>
-유저에게 보이는 부분

<프레임워크 구조의 예: MVC 아키텍쳐>
-모델->반영->뷰->유저
-모델->조회 및 수정->컨트롤러->유저

<리액트>
애플리케이션 규모가 너무 커져 데이터 수정이 복잡해졌다.
페이스북 개발팀에서는 이 문제를 해결하기 위해 자바스크립트 라이브러리 React를 개발했다.
React는 수정 후 반영 시 기존 뷰를 날려버리고 새롭게 렌더링한다.
이는 새롭게 리렌더링하면서 성능을 아끼고, 최적의 유저 경험을 제공하기 윟마이다.
다른 구조의 프레임워크와는 다르게 오직 View만 신경쓴다.
리액트는 프레임워크가 아니라 라이브러리이다.

<컴포넌트>
재사용이 가능한 AIP이다. 수많은 기능들을 내장한다.

<렌더링>
사용자 화면에 뷰를 보여주는 것을 말한다. 

<초기 렌더링>
리액트 컴포넌트가 최초로 실행되는 것을 말한다.

<리렌더링>
컴포넌트의 데이터 변경으로 다시 실행되는 것을 말한다.

<render() 함수>
render 함수는 뷰가 어떻게 생겼고 어떻게 작동하는지 객체를 반환한다.
기존의 다른 프레임워크처럼 html 문자열을 반환하는 대신, 뷰가 어떻게 생겼고 어떻게 작동하는지 정보를 지닌 객체를 반환한다.
컴포넌트 안에 또 다른 컴포넌트가 들어갈 수 있다.
최상위 컴포넌트의 렌더링 작업이 끝나면 최상위 컴포넌트가 지니고 있는 정보들을 사용하여 html을 만들고 DOM을 형성한다.
[초기 렌더링 -> HTML 마크업 -> DOM에 주입 -> 렌더링 완료]

<조화 과정>
리액트에서 뷰를 업데이트할 때는 '업데이트'라고 하기보다는 '조화 과정을 거친다.'라고 한다.
컴포넌트에 변화가 있을 때 변화에 따라 뷰가 변경되는 것처럼 보이지만, 사실은 새로운 요소로 갈아끼우기 때문이다.
조화 과정을 render() 함수가 수행한다.
render함수가 반환하는 결과를 바로 DOM에 반영하지 않고 render 전의 함수와 후의 컴포넌트 정보를 비교한다.
자바스크립트를 사용하여 두가지 뷰를 최소한의 연산으로 비교한 후 둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트 한다.

<Virtual DOM>
1. 데이터를 업데이트 한다.
2. 전체 UI를 Virtual DOM에 리렌더링한다.
3. 기존 Virtual DOM에 있던 내용과 현재 내용을 비교한다.
4. 바뀐 부분만 실제 DOM에 적용한다.

<오해>
Virtual DOM을 사용한다고 해서 사용하지 않을 때와 비교하여 무조건 빠른 것은 아니다.
"우리는 다음 문제를 해결하려고 리액트를 만들었습니다. 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축하기"

사실 속도가 느려지는 문제를 해결하기 위해서는 리액트를 사용하지 않고도 코드 최적화를 열심히 하면 DOM 작업이 느려지는 문제를 해결할 수 있다.
따라서 리액트를 사용하려는 궁극적 목적을 염두하고 적절한 곳에 사용해야 한다.

<React와 Virtual DOM의 장점>
- 업데이트 처리 간결성

<단점>
리액트는 다른 프레임워크와는 다르게 정말 '뷰'만 신경쓰기 때문에
ajax, 데이터모델링, 라우팅 등의 기능들은 다른 라이브러리를 이용해야한다.
즉, 많은 프레임워크와 라이브러리와 혼용해야할 필요가 있다.

<Node.js>
자바스크립트 런타임. 이것으로 인해 웹 브라우저 환경이 아닌 곳에서도 자바스크립트를 연산할 수 있다.

<babel>
최신 자바스크립트 언어인 ECMAScript6를 호환시켜준다.

<webpack>
모듈화된 코드를 한 파일로 합치고(번들링) 코드를 수정할 때 마다 웹 브라우저를 리로딩한다.

<npm>
Node.js 패키지 매니저.
수많은 개발자가 만든 모듈(재사용 가능한 코드)을 설치하고 해당 모듈 버전을 관리하는 도구이다.
리액트 역시 하나의 모듈이다.

<yarn>
yarn은 npm의 문제점을 개선한 패키지 메니저로 npm을 대체할 수 있다. 이 도구를 사용하면 패키지를 훨씬 빠르게 설치할 수 있다.





